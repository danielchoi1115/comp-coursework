package comp3111.covid;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.DateCell;
import javafx.scene.control.DatePicker;
import javafx.scene.control.ListView;
import javafx.scene.control.Tab;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;

/**
 * Building on the sample skeleton for 'ui.fxml' Controller Class generated by SceneBuilder 
 */
public class Controller {

    @FXML
    private Tab tabTaskZero;

    @FXML
    private TextField textfieldISO;

    @FXML
    private Button buttonConfirmedDeaths;

    @FXML
    private TextField textfieldDataset;

    @FXML
    private Button buttonRateOfVaccination;

    @FXML
    private Button buttonConfirmedCases;

    @FXML
    private Tab tabReport1;

    @FXML
    private Tab tabReport2;

    @FXML
    private Tab tabReport3;

    @FXML
    private Tab tabApp1;

    @FXML
    private Tab tabApp2;

    @FXML
    private Tab tabApp3;

    @FXML
    private TextArea textAreaConsole;

//    Table A
    private LinkedHashMap<String, ArrayList<LocalDate>> countryDateMap;
    
    private ObservableList<CheckBox> tableA_countryCheckbox = FXCollections.observableArrayList();
    
    private ArrayList<LocalDate> dateLists;
    
    @FXML 
    private ListView<CheckBox> tableA_countryCheckBoxList;
    
    @FXML
    private Button displayTableA;
    
    @FXML
    private DatePicker tableA_datePicker;
    
    @FXML
    private TableView<ConfirmedCase>  TableA;
    
    @FXML
    private TableColumn<ConfirmedCase, String> countryName;
    @FXML
    private TableColumn<ConfirmedCase, String> totalCases;
    @FXML
    private TableColumn<ConfirmedCase, String> totalCasesPerM;
    
//    Chart A
    @FXML
    private LineChart<String, Number> chartA_lineChart; 
 
    private ObservableList<CheckBox> chartA_countryCheckbox = FXCollections.observableArrayList();
    
    @FXML
    private DatePicker chartA_datePickerFrom;
    
    @FXML
    private DatePicker chartA_datePickerTo;
    
    @FXML 
    private ListView<CheckBox> chartA_countryCheckBoxList;
    
    @FXML
    private Button displayChartA;
    
    @FXML
    private CategoryAxis chartA_xAxis ;

    @FXML
    private NumberAxis chartA_yAxis ;
    
    @FXML
    protected void initialize() {	
    	dateLists = DataAnalysis.getDates();
    	countryDateMap = DataAnalysis.getCountryDateMap();
    	addCountryCheckbox();
    	setMinMaxOfDatePicker();
		
    	tableA_disableUnavailableCountry();
    	chartA_disableUnavailableCountry();
    	tableA_countryCheckBoxList.setItems(tableA_countryCheckbox);
    	chartA_countryCheckBoxList.setItems(chartA_countryCheckbox);
    	chartA_xAxis.setAnimated(false);
    	chartA_lineChart.setCreateSymbols(false);
    	
    }
    
    /**
     * class variable
     */
	int x_count = 0;
    
    /**
     *  Task Zero
     *  To be triggered by the "Confirmed Cases" button on the Task Zero Tab 
     *  
     */
    @FXML
    void doConfirmedCases(ActionEvent event) {
    	String iDataset = textfieldDataset.getText();
    	String iISO = textfieldISO.getText();
    	String oReport = DataAnalysis.getConfirmedCases(iDataset, iISO);
    	textAreaConsole.setText(oReport);
    }

    
    /**
     *  Task Zero
     *  To be triggered by the "Confirmed Deaths" button on the Task Zero Tab
     *  
     */
    @FXML
    void doConfirmedDeaths(ActionEvent event) {
    	String iDataset = textfieldDataset.getText();
    	String iISO = textfieldISO.getText();
    	String oReport = DataAnalysis.getConfirmedDeaths(iDataset, iISO);
    	textAreaConsole.setText(oReport);
    }

  
    /**
     *  Task Zero
     *  To be triggered by the "Rate of Vaccination" button on the Task Zero Tab
     *  
     */
    @FXML
    void doRateOfVaccination(ActionEvent event) {
    	String iDataset = textfieldDataset.getText();
    	String iISO = textfieldISO.getText();
    	String oReport = DataAnalysis.getRateOfVaccination(iDataset, iISO);
    	textAreaConsole.setText(oReport);
    }  
    
	@FXML 
    void doDisplayTableA(ActionEvent event) {
    	ArrayList<String> selectedCountries = new ArrayList<>();
    	for (CheckBox country: tableA_countryCheckBoxList.getItems()) {
    		if (country.isSelected()) {
    			selectedCountries.add(country.getText());
    		}
    	}
    	
    	if (selectedCountries.size() == 0) {
    		noCountrySelectedAlert();
    		return;
    	}
    	
    	LocalDate dateSelected = tableA_datePicker.getValue();
    	
    	if (!validateDate(dateSelected)) {
    		notValidDateAlert();
    		return;
    	}
    	
    	textAreaConsole.setText(dateSelected.toString());

    	ObservableList<ConfirmedCase> confirmedCaseList = DataAnalysis.getConfirmedCases(selectedCountries, dateSelected);

    	if (confirmedCaseList.size() == 0) {
    		noDataAlert();
    		return;
    	}
    	
    	countryName.setCellValueFactory(new PropertyValueFactory<ConfirmedCase, String>("countryName"));
    	totalCases.setCellValueFactory(new PropertyValueFactory<ConfirmedCase, String>("totalCases"));
    	totalCasesPerM.setCellValueFactory(new PropertyValueFactory<ConfirmedCase, String>("totalCasesPerM"));
    	
    	TableA.setItems(confirmedCaseList);
    	
    	
    }
    
	@FXML 
    void doDisplayChartA(ActionEvent event) {
		chartA_lineChart.getData().clear();
		
		ArrayList<String> selectedCountries = new ArrayList<>();
    	for (CheckBox country: chartA_countryCheckBoxList.getItems()) {
    		if (country.isSelected()) {
    			selectedCountries.add(country.getText());
    		}
    	}
    	
    	if (selectedCountries.size() == 0) {
    		noCountrySelectedAlert();
    		return;
    	}
    	
    	LocalDate dateFrom = chartA_datePickerFrom.getValue();
    	LocalDate dateTo = chartA_datePickerTo.getValue();
    	
    	if (!validateDate(dateFrom, dateTo)) {
    		return;
    	}
    	
		LinkedHashMap<String, ArrayList<LinkedHashMap<LocalDate, Double>>> cumulativeMap = DataAnalysis.getCumulativeMap(selectedCountries, dateFrom, dateTo);
		
		
		
		if (cumulativeMap.size() == 0) {
			noDataAlert();
		}
		
        chartA_lineChart.setTitle("Cumulative Confirmed COVID-19 Cases (per 1M)");
		ObservableList<XYChart.Series<String, Number>> seriesList = FXCollections.observableArrayList();
		
		cumulativeMap.forEach((countryName, dateMapList) -> {
			XYChart.Series<String, Number> series = new XYChart.Series<String, Number>();
			series.setName(countryName);
			dateMapList.forEach(dateMap -> {
				String date = dateMap.keySet().toArray()[0].toString();
				Number record = (Number) dateMap.values().toArray()[0];
				series.getData().add(new XYChart.Data<String, Number>(date, record)) ;
				x_count += 1;
			});
			seriesList.add(series);
		});
	
		chartA_lineChart.setData(seriesList);
		
	}
	
	void noCountrySelectedAlert() {
		Alert alert = new Alert(AlertType.WARNING);
		alert.setTitle("Warning Dialog");
		alert.setHeaderText("No Country selected!");
		alert.setContentText("Please select at least one country!");
		alert.showAndWait();
	}
	void noDataAlert() {
		Alert alert = new Alert(AlertType.WARNING);
		alert.setTitle("Warning Dialog");
		alert.setHeaderText("Data is not Found!");
		alert.setContentText("Please select different date or country!");
		alert.showAndWait();
	}
	void notValidDateAlert() {
		Alert alert = new Alert(AlertType.WARNING);
		alert.setTitle("Warning Dialog");
		alert.setHeaderText("Date is invalid!");
		alert.setContentText("Please provide valid date!");
		alert.showAndWait();
	}
	
	boolean validateDate(LocalDate dateSelected) {
		
		LocalDate minDate = Collections.min(dateLists);
    	LocalDate maxDate = Collections.max(dateLists);
    	
    	try {
    		if (DataAnalysis.isBetween(dateSelected, minDate, maxDate)) {
    			return true;
    		}
    		return false;
    	} catch(Exception e) {
    		textAreaConsole.setText(e.toString());
    		return false;
    	}
	}
	
	boolean validateDate(LocalDate dateFrom, LocalDate dateTo) {
    	if (validateDate(dateFrom) && validateDate(dateTo) && (dateFrom.isBefore(dateTo) || dateFrom.isEqual(dateTo))) {
    		return true;
    	}	
    	notValidDateAlert();
    	return false;
	}
	
	// Add countries that can be checked for user input
    void addCountryCheckbox() {
    	ArrayList<String> countries = DataAnalysis.getCountries();
    	for (String country: countries) {
    		CheckBox checkbox = new CheckBox(country);
    		tableA_countryCheckbox.add(checkbox);
    		
    		CheckBox checkbox2 = new CheckBox(country);
    		chartA_countryCheckbox.add(checkbox2);
    	}
    	
    }
 
    
    // Disable Dates that are out of range
    void setMinMaxOfDatePicker(){
    	LocalDate minDate = Collections.min(dateLists);
    	LocalDate maxDate = Collections.max(dateLists);
//    	tableA
    	tableA_datePicker.setDayCellFactory(d ->
    	           new DateCell() {
    	               @Override 
    	               public void updateItem(LocalDate item, boolean empty) {
    	                   super.updateItem(item, empty);
    	                   setDisable(item.isAfter(maxDate) || item.isBefore(minDate));
    	               }});
    	tableA_datePicker.setValue(maxDate);
    
//    	chartA
    	chartA_datePickerFrom.setDayCellFactory(d ->
        new DateCell() {
            @Override 
            public void updateItem(LocalDate item, boolean empty) {
                super.updateItem(item, empty);
                setDisable(item.isAfter(maxDate) || item.isBefore(minDate));
            }});
    	chartA_datePickerFrom.setValue(maxDate);
    	chartA_datePickerTo.setDayCellFactory(d ->
        new DateCell() {
            @Override 
            public void updateItem(LocalDate item, boolean empty) {
                super.updateItem(item, empty);
                setDisable(item.isAfter(maxDate) || item.isBefore(minDate));
            }});
    	chartA_datePickerTo.setValue(maxDate);
    	
    }
    
//    disable countries that are not available on selected Dates
    @FXML
    void tableA_disableUnavailableCountry() {
    	LocalDate dateSelected = tableA_datePicker.getValue();
    	if (!validateDate(dateSelected)) {
    		return;
    	}
    	tableA_countryCheckbox.forEach(checkbox -> {
    		ArrayList<LocalDate> dateList = countryDateMap.get(checkbox.getText());
    		if (!DataAnalysis.isBetween(dateSelected, dateList.get(0), dateList.get(1))) {
    			checkbox.setDisable(true);
    		}
    		else {
    			checkbox.setDisable(false);
    		}
    	});
    }
    
    @FXML
    void chartA_disableUnavailableCountry() {
    	LocalDate dateFrom = chartA_datePickerFrom.getValue();
    	LocalDate dateTo = chartA_datePickerTo.getValue();
    	if (!validateDate(dateFrom, dateTo)) {
    		return;
    	}
    	chartA_countryCheckbox.forEach(checkbox -> {
    		ArrayList<LocalDate> dateList = countryDateMap.get(checkbox.getText());
    		if (!DataAnalysis.isBetween(dateFrom, dateList.get(2), dateList.get(3)) && !DataAnalysis.isBetween(dateTo, dateList.get(2), dateList.get(3))) {
    			checkbox.setDisable(true);
    		}
    		else {
    			checkbox.setDisable(false);
    		}
    	});
    }
}

